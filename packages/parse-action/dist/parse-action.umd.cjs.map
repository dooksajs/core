{"version":3,"file":"parse-action.umd.cjs","sources":["../../object-hash/dist/object-hash.js","../lib/main.js"],"sourcesContent":["const i = {\n  Object,\n  Array,\n  Number,\n  Boolean,\n  String\n}, s = {\n  /**\n   * Create Adler 32 hex string from object\n   * @param {Object} source - The original object used to create the hash\n   * @returns {string} - Adler 32 hex string\n   */\n  process(e) {\n    try {\n      if (!e)\n        throw new Error(\"source is undefined\");\n      const t = {};\n      this._sortType(t, e);\n      const n = new TextEncoder(), r = JSON.stringify(t), o = n.encode(r);\n      return this._adler(o);\n    } catch (t) {\n      console.error(t);\n    }\n  },\n  _defaultType(e) {\n    const t = e == null ? void 0 : e.constructor.name;\n    return i[t]();\n  },\n  _adler(e) {\n    let n = 1, r = 0;\n    e = new Uint8Array(e);\n    for (let o = 0; o < e.length; o++)\n      n += e[o], r += n;\n    return n %= 65521, r %= 65521, this._hex((r << 16 | n) >>> 0, 8);\n  },\n  /**\n   * Translates a character into an ordinal.\n   *\n   * @param {char} c\n   * @returns {number}\n   *\n   * @example\n   * // returns 97\n   * this._ord('a');\n   */\n  _ord(e) {\n    if (e.length === 2) {\n      const t = e.charCodeAt(0), n = e.charCodeAt(1);\n      if (t >= 55296 && t < 56320 && n >= 56320 && n < 57344)\n        return (t - 55296) * 1024 + n - 56320 + 65536;\n    }\n    return e.charCodeAt(0);\n  },\n  /**\n   * Converts a character or number to its hex representation.\n   *\n   * @param {char|number} c\n   * @param {number} [length=2] - The width of the resulting hex number.\n   * @returns {string}\n   *\n   * @example\n   * // returns \"6e\"\n   * this._hex(\"n\")\n   *\n   * // returns \"6e\"\n   * this._hex(110)\n   */\n  _hex(e, t = 2) {\n    return e = typeof e == \"string\" ? this._ord(e) : e, e.toString(16).padStart(t, \"0\");\n  },\n  /**\n   * Sort source by data type\n   * @private\n   * @param {Object} target - Alphanumerically sorted object\n   * @param {*} source - Current value\n   * @returns\n   */\n  _sortType(e, t) {\n    if (t == null)\n      throw new Error(\"objectHash: value cannot be undefined\");\n    return Array.isArray(t) ? t = this._array(e, t) : typeof t == \"object\" ? t = this._object(e, t) : typeof t == \"function\" && (t = t.toString()), t;\n  },\n  /**\n   * Traverse arrays values\n   * @param {Object} target - Alphanumerically sorted object\n   * @param {Array} source - Current nested array\n   * @returns {Array}\n   */\n  _array(e, t) {\n    t = t.slice();\n    for (let n = 0; n < t.length; n++) {\n      const r = t[n];\n      e = this._defaultType(r), t[n] = this._sortType(e, r);\n    }\n    return t;\n  },\n  /**\n   * Sort object keys alphanumerically\n   * @private\n   * @param {Object} target - Alphanumerically sorted object\n   * @param {Object} source - Current nested object\n   * @returns {Object}\n   */\n  _object(e, t) {\n    const n = Object.keys(t);\n    n.sort();\n    for (let r = 0; r < n.length; r++) {\n      const o = n[r];\n      e[o] = this._defaultType(t[o]), e[o] = this._sortType(e[o], t[o]);\n    }\n    return e;\n  }\n};\nexport {\n  s as default\n};\n","import objectHash from '@dooksa/object-hash'\n\n/**\n * @typedef {Object} Action\n * @property {Object.<string, ActionItem>} action.items - Collection of actions\n * @property {Object[]} action.sequence - The sequence that will construct the final action\n * @property {string} action.sequence[].id - Reference id to an action item\n * @property {Array.<string>} action.sequence[].path - A list of keys related to the target object that is used to place the returned action value\n */\n\n/**\n * @typedef {Object} ActionItem\n * @property {string} ActionItem._$a - Action name\n * @property {(Object|Array|string|number)} ActionItem._$p - Action parameters\n */\n\n/**\n * Convert template action to dsAction data\n * @param {Object} source\n * @param {string} source.dsAction - The function name\n * @param {(Object|Array|string|number)} source.dsParams - The literal or computed parameters used to pass to the function\n * @returns {Action} - Data that can be used to set dsAction/items and dsAction/sequence\n */\nexport default (source) => {\n  const actions = findActions({ source }).actions\n  const items = {}\n  const sequence = []\n  let children = []\n  let depth = actions[0].path.length\n\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    const id = objectHash.process(action.source)\n    const item = {\n      path: action.path,\n      id\n    }\n    let node = source\n\n    if (depth !== action.path.length) {\n      for (let i = 0; i < children.length; i++) {\n        const childAction = actions[children[i]]\n\n        for (let k = 0; k < action.path.length; k++) {\n          if (action.path[k] !== childAction.path[k]) {\n            children.splice(i, 1)\n            break\n          }\n        }\n      }\n\n      if (children.length) {\n        item.children = children.slice()\n        children = []\n      }\n    }\n\n    // exclude own key\n    const keyLength = action.path.length - 1\n\n    for (let i = 0; i < keyLength; i++) {\n      const key = action.path[i]\n\n      node = node[key]\n    }\n\n    children.push(i)\n    depth = action.path.length\n\n    if (keyLength > -1) {\n      node[action.path[keyLength]] = {\n        _$id: id\n      }\n    }\n\n    sequence.push(item)\n\n    items[id] = action.source\n  }\n\n  const sequenceId = objectHash.process(sequence)\n\n  return { items, sequence, sequenceId }\n}\n\n/**\n * Extract actions from action templates\n * @private\n * @param {Object} param\n * @param {Object} param.source - Action template\n * @returns\n */\nconst findActions = ({\n  source,\n  node = { path: [] },\n  actions = [],\n  lastNode = 0\n}) => {\n  if (source.dsAction) {\n    source._$a = source.dsAction\n    delete source.dsAction\n\n    if (source.dsParams) {\n      source._$p = source.dsParams\n      delete source.dsParams\n    }\n\n    actions.unshift({\n      path: node.path.slice(),\n      source\n    })\n  }\n\n  const keys = Object.keys(source)\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    const element = source[key]\n\n    // store current node split â…„\n    if (keys.length > 1) {\n      lastNode = node.path.length\n    }\n\n    if (typeof element === 'object') {\n      node.path.push(key)\n\n      const result = findActions({\n        source: element,\n        node,\n        actions,\n        lastNode\n      })\n\n      // clear keys up until last working node\n      node.path = result.node.path.slice(0, lastNode)\n    }\n  }\n\n  return { actions, node }\n}\n"],"names":["i","s","n","r","o","main","source","actions","findActions","items","sequence","children","depth","action","id","objectHash","item","node","childAction","k","keyLength","key","sequenceId","lastNode","keys","element","result"],"mappings":"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"}