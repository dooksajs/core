import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'

// Import plugins
import * as corePlugins from '../packages/plugins/src/core/index.js'
import * as clientPlugins from '../packages/plugins/src/client/index.js'
import * as serverPlugins from '../packages/plugins/src/server/index.js'
import capitalize from '../packages/utils/src/capitalise.js'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const OUTPUT_FILE = path.resolve(__dirname, '../packages/types/src/state-registry.js')

const registry = {}
const typeDefinitions = {}


function getTypeFromSchema (schema, name) {
  if (!schema) return 'any'

  switch (schema.type) {
    case 'string':
      return 'string'
    case 'number':
      return 'number'
    case 'boolean':
      return 'boolean'
    case 'array':
      if (schema.items) {
        return `${getTypeFromSchema(schema.items, name)}[]`
      }
      return 'any[]'
    case 'object':
      if (schema.properties) {
        // Generate a named type for this object if it doesn't exist
        const typeName = name.split('/').map(capitalize).join('')
        if (!typeDefinitions[typeName]) {
          const props = []
          for (const [key, propSchema] of Object.entries(schema.properties)) {
            const propType = getTypeFromSchema(propSchema, `${name}/${key}`)
            const optional = propSchema.required ? '' : '?'
            props.push(` * @property {${propType}} [${key}]`)
          }

          typeDefinitions[typeName] = `/**
 * @typedef {Object} ${typeName}
${props.join('\n')}
 */`
        }
        return typeName
      }
      return 'Object<string, any>'
    case 'collection':
      // For collection, the "item" type is what's inside
      if (schema.items) {
        return getTypeFromSchema(schema.items, name)
      }
      return 'any'
    default:
      return 'any'
  }
}

function processPlugins (plugins) {
  for (const plugin of Object.values(plugins)) {
    if (plugin && plugin.state && plugin.state.schema) {
      const pluginName = plugin.name
      for (const [key, schema] of Object.entries(plugin.state.schema)) {
        const fullKey = `${pluginName}/${key}`

        let itemType = 'any'
        let type = schema.type

        if (type === 'collection') {
          itemType = getTypeFromSchema(schema.items, fullKey)
        } else {
          itemType = getTypeFromSchema(schema, fullKey)
        }

        registry[fullKey] = {
          type: type,
          item: itemType
        }
      }
    }
  }
}

console.log('Processing plugins...')
processPlugins(corePlugins)
processPlugins(clientPlugins)
processPlugins(serverPlugins)

console.log('Generating types...')

let content = `/**
 * This file is auto-generated by scripts/build-state-registry.js
 * Do not edit this file directly.
 */

/**
 * @template T
 * @typedef {Object} DooksaCollectionStateRegistryItem
 * @property {'collection'} type
 * @property {T} item
 */

/**
 * @template T
 * @typedef {Object} DooksaArrayStateRegistryItem
 * @property {'array'} type
 * @property {T} item
 */

/**
 * @template T
 * @typedef {Object} DooksaObjectStateRegistryItem
 * @property {'object'} type
 * @property {T} item
 */

/**
 * @typedef {Object} DooksaStringStateRegistryItem
 * @property {'string'} type
 * @property {string} item
 */

/**
 * @typedef {Object} DooksaNumberStateRegistryItem
 * @property {'number'} type
 * @property {number} item
 */

/**
 * @typedef {Object} DooksaBooleanStateRegistryItem
 * @property {'boolean'} type
 * @property {boolean} item
 */
`

// Append Type Definitions
for (const def of Object.values(typeDefinitions)) {
  content += `\n${def}\n`
}

// Append Registry
content += `\n/**\n * @typedef {{\n`
for (const [key, meta] of Object.entries(registry)) {
  let wrapperType = ''
  let itemType = meta.item

  switch (meta.type) {
    case 'collection':
      wrapperType = `DooksaCollectionStateRegistryItem<${itemType}>`
      break
    case 'array':
      wrapperType = `DooksaArrayStateRegistryItem<${itemType}>`
      break
    case 'object':
      wrapperType = `DooksaObjectStateRegistryItem<${itemType}>`
      break
    case 'string':
      wrapperType = 'DooksaStringStateRegistryItem'
      break
    case 'number':
      wrapperType = 'DooksaNumberStateRegistryItem'
      break
    case 'boolean':
      wrapperType = 'DooksaBooleanStateRegistryItem'
      break
    default:
      wrapperType = `DooksaObjectStateRegistryItem<any>` // Fallback
  }

  // Align keys for readability (optional but nice)
  const padding = ' '.repeat(Math.max(0, 30 - key.length))
  content += ` * "${key}": ${padding}${wrapperType},\n`
}
content += ` * }} DooksaStateRegistry\n */\n\nexport {}\n`

fs.writeFileSync(OUTPUT_FILE, content)
console.log(`Generated state types at ${OUTPUT_FILE}`)
